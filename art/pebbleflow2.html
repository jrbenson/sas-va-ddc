<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">

<title>Pebble Flow</title>
<script>let exports = {};/*Hack to handle NPM package*/</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/90/three.min.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/stats.js/r17/build/stats.min.js"></script>
<script src="https://cdn.rawgit.com/Pomax/bezierjs/v2.2.5/bezier.js"></script>
<script src="https://cdn.rawgit.com/robbrit/randgen/5e853df3/lib/randgen.js"></script>
<script src="https://cdn.rawgit.com/gorhill/Javascript-Voronoi/1.0.0/rhill-voronoi-core.min.js"></script>
<style>
	html, body { margin: 0; padding: 0; height: 100%; overflow: hidden }
	canvas { width: 100%; height: 100% }
</style>
</head>
<body>
<script>

// Config
let config = {
	"frames_per_second": 60,
	"seconds_per_observation": 20,
	"palettes": {
		"sunrise": {
			"background_a": "#fffee8",
			"background_b": "#f9f6d2",
			"base": "#c8d2e9",
			"alt_a": "#ffa321",
			"alt_b": "#5498fc",
			"outline": "#fef666",
			"base_alpha": 200
		},
		"sunny": {
			"background_a": "#9ac4ff",
			"background_b": "#508ecc",
			"base": "#cde5ff",
			"alt_a": "#fff3ad",
			"alt_b": "#fef365",
			"outline": "#fff7d6",
			"base_alpha": 150
		},
		"cloudy": {
			"background_a": "#64758c",
			"background_b": "#5b697d",
			"base": "#a3b2be",
			"alt_a": "#ebedf2",
			"alt_b": "#34445a",
			"outline": "#d0d5d9",
			"base_alpha": 100
		},
		"sunset": {
			"background_a": "#72113D",
			"background_b": "#490728",
			"base": "#d31c0e",
			"alt_a": "#ff9000",
			"alt_b": "#fece14",
			"outline": "#ffdc6c",
			"base_alpha": 150
		},
		"evening": {
			"background_a": "#5274b4",
			"background_b": "#211b1f",
			"base": "#1c2934",
			"alt_a": "#66302f",
			"alt_b": "#211b1f",
			"outline": "#6c6c7a",
			"base_alpha": 100
		}
	},
	"stroke_weight": 1.0,
	"outline_alpha": 255,
	"region_alpha": 255,
	"font_family": "Arial",
	"font_size": 36,
	"draw_qr": true,
	"qr_url": "http://www.sas.com",
	"qr_size_height_ratio": 0.1,
	"apply_blur": true,
	"blur_points": 10,
	"blur_radius": 1,
	"point_spacing": 7,
	"point_jitter": 0.75,
	"equatorial_stddev_ratio": 1.00,
	"equatorial_thinning_iterations": 10,
	"rand_curve_iterations": 3,
	"rand_curve_step": 100,
	"rand_curve_walk_diff_ratio": 0.3,
	"rand_walk_thin_dist_ratio": 0.18,
	"simplify_epsilon": 6.0,
	"region_scale": 0.9,
	"value_impact_dist_ratio": 0.33,
	"sun_impact_dist_ratio": 0.66,
	"debug": true
}

// Functions
function getPointGrid( bounds, x_spacing, y_spacing, jitter ) {

	let points = [];

	x_grid_width = Math.floor( bounds.getSize().x / x_spacing );
	y_grid_width = Math.floor( bounds.getSize().y / y_spacing );

	for ( x = 0; x < x_grid_width; x++) {
	  for ( y = 0; y < y_grid_width; y++) {
	    let pnt = new THREE.Vector3( bounds.min.x + x * x_spacing - ( ( -jitter * 0.5 ) * x_spacing ) + ( jitter * runif( 0, x_spacing ) ),
	                          		bounds.min.y + y * y_spacing - ( ( -jitter * 0.5 ) * y_spacing ) + ( jitter * runif( 0, y_spacing ) ),
	                          		0 );
	    points.push( pnt );
	  }
	}

	return points;
}

function getPointPerimeter( bounds, x_spacing, y_spacing, jitter ) {

	let points = [];

	let new_bounds = bounds.clone();
	new_bounds.min.x = new_bounds.min.x - x_spacing*2;
	new_bounds.min.y = new_bounds.min.y - y_spacing*2;
	new_bounds.max.x = new_bounds.max.x + x_spacing*2;
	new_bounds.max.y = new_bounds.max.y + y_spacing*2;

	x_grid_width = Math.floor( new_bounds.getSize().x / x_spacing );
	y_grid_width = Math.floor( new_bounds.getSize().y / y_spacing );

	let xs = [ 0, x_grid_width ];
	let ys = [ 0, y_grid_width ];

	for ( x of xs ) {
	  for ( y = 0; y < y_grid_width; y++ ) {
	    let pnt = new THREE.Vector3( new_bounds.min.x + x * x_spacing - ( ( -jitter * 0.5 ) * x_spacing ) + ( jitter * runif( 0, x_spacing ) ),
	    								new_bounds.min.y + y * y_spacing - ( ( -jitter * 0.5 ) * y_spacing ) + ( jitter * runif( 0, y_spacing ) ),
	                          		0 );
	    points.push( pnt );
	  }
	}
	for ( y of ys ) {
		for ( x = 0; x < x_grid_width; x++) {
			let pnt = new THREE.Vector3( new_bounds.min.x + x * x_spacing - ( ( -jitter * 0.5 ) * x_spacing ) + ( jitter * runif( 0, x_spacing ) ),
										new_bounds.min.y + y * y_spacing - ( ( -jitter * 0.5 ) * y_spacing ) + ( jitter * runif( 0, y_spacing ) ),
              							0 );
			points.push( pnt );
		}
	}

	return points;
}

function getThinnedPointsAroundHorizontalLine( points, y_line, std_deviation ) {

	let kept_points = [];

	for ( let pnt of points ) {
		y_dist = Math.abs( y_line - pnt.y );
		rand_y_dist = Math.abs( y_line - rnorm( y_line, std_deviation ) );

		if ( y_dist > rand_y_dist ) {
			kept_points.push( pnt );
		}
	}

	return kept_points;
}

function getVoronoiShapes( points, bounds, smooth = false ) {

	let shapes = [];

	let v = new Voronoi();
	let bb = { xl: bounds.min.x, xr: bounds.max.x, yt: bounds.min.y, yb: bounds.max.y };
	let vDiagram = v.compute( points, bounds );

	for ( cell of vDiagram.cells ) {
		if ( cell.site.x > bb.xl && cell.site.x < bb.xr && cell.site.y > bb.yt && cell.site.y < bb.yb ) {
			let shape = new THREE.Shape();
			if ( !smooth ) {
			    for ( let i = 0; i < cell.halfedges.length; i++ ) {
			        let start = cell.halfedges[i].getStartpoint();
			        let end = cell.halfedges[i].getEndpoint();
			        if ( i === 0 ) {
			            shape.moveTo( start.x, start.y );
			        }
			        shape.lineTo( end.x, end.y );
			    }
			} else {
				let starts = [];
				let ends = [];
				let mids = [];
				for ( let i = 0; i < cell.halfedges.length; i++ ) {
			        starts.push( cell.halfedges[i].getStartpoint() );
			        ends.push( cell.halfedges[i].getEndpoint() );
			        mids.push( { x: 0.5 * starts[i].x + 0.5 * ends[i].x, y: 0.5 * starts[i].y + 0.5 * ends[i].y } )
				}
				shape.moveTo( mids[0].x, mids[0].y );
				for ( let i = 0; i < mids.length - 1; i++ ) {
					i_next = ( i + 1 ) % mids.length;
			        shape.quadraticCurveTo( ends[i].x, ends[i].y, mids[i_next].x, mids[i_next].y );
			    }
			}
	    		shapes.push( shape )
	    }
	}

	return shapes;
}

//Globals
let camera, scene, renderer;

let width, height, bounds;

let points;

let stats;

// Init
function init() {
	setup();
	update();
}

// Setup
function setup() {

	width = window.innerWidth;
	height = window.innerHeight;
	bounds = new THREE.Box2( new THREE.Vector2( 0, 0 ), new THREE.Vector2( width, height ) );

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( width, height );
	document.body.appendChild( renderer.domElement );

	let aspect = width / height;
	camera = new THREE.OrthographicCamera( 0, width, 0, height );
	//camera = new THREE.OrthographicCamera( -50, width+50, -50, height+50 );
	/* camera = new THREE.PerspectiveCamera( 75, aspect, 1, 3000 );*/
	camera.position.z = 500;

	scene = new THREE.Scene();
	scene.background = new THREE.Color( 0x5274b4 );

	let light = new THREE.PointLight( 0xffffff, 1, 0 );
	light.position.set( width/3.0, height/2.0, -150 );
	scene.add( light );

	let centers = new Map();
	points = getPointGrid( bounds, config.point_spacing, config.point_spacing, config.point_jitter );
	points = points.concat( getPointPerimeter( bounds, config.point_spacing, config.point_spacing, 0.001 ) );
	points = getThinnedPointsAroundHorizontalLine( points, height / 2, config.equatorial_stddev_ratio * height );
	vshapes = getVoronoiShapes( points, bounds, smooth = true );
	for ( vshape of vshapes ) {
		let geometry = new THREE.ShapeGeometry( vshape );
		geometry.computeBoundingBox();
		let center = geometry.boundingBox.getCenter();
		geometry.translate( -center.x, -center.y, -center.z );
		geometry.scale( 0.75, 0.75, 0.75 );
		geometry.translate( center.x, center.y, center.z );
		let material = new THREE.MeshPhongMaterial( {
			color: Math.random() * 0xffffff,
			emissive: 0x333333,
			side: THREE.DoubleSide,
			flatShading: true
		} );
		material.wireframe = false;
		let mesh = new THREE.Mesh( geometry, material );
		
		// mesh.scale.set( 0.75, 0.75, 0.75 );
		// //mesh.scale.set( 8,8,8 );
		scene.add( mesh );
	}

	if ( config.debug ) {
		let pointGeom = new THREE.Geometry();
		for ( p of points ) {
			pointGeom.vertices.push( p );
		}
		let pointMat = new THREE.PointsMaterial( { color: 0x000000, size: 2, sizeAttenuation: false } );
		let vPoints = new THREE.Points( pointGeom, pointMat );
		scene.add( vPoints );
	}

	// Initialize stats overlay
	if ( config.debug ) {
		stats = new Stats();
		document.body.appendChild( stats.dom );
	}
}

// Update
function update() {
	render();
	requestAnimationFrame( update );

	if ( config.debug ) { stats.update(); }
}

// Render
function render() {

	/* p.background( 255 );

	for ( let pnt of points ) {
		p.point( pnt.x, pnt.y );
	}

	if ( p.mouseIsPressed ) {
		p.fill( 0 );
	} else {
		p.fill( 255 );
	}
	p.ellipse( p.mouseX, p.mouseY, 80, 80 ); */

	renderer.render( scene, camera );
}

init();

</script>
</body>
</html>